<application>
  <component name="AppStorage">
    <histories>
      <item value="Generic components" />
      <item value="noinspection" />
      <item value="Annotation `parameter` is not allowed on comment from type `css` in `_unit.scss:20:25`." />
      <item value="Map of breakpoints and values or single value to use." />
      <item value="Single value, breakpoint name, or list of breakpoint names to use. &quot;auto&quot; by default." />
      <item value="For &quot;auto&quot;, `$-zf-bp-value` is the corresponding breakpoint value in `$map` and is passed to `@content`, which is made responsive for each breakpoint of `$map`." />
      <item value="For a breakpoint name, `$-zf-bp-value` is the corresponding breakpoint value in `$map`." />
      <item value="For a single value, `$-zf-bp-value` is this value." />
      <item value="Generate the `@content` passed to the mixin with a value `$-zf-bp-value` related to a breakpoint, depending on the `$name` parameter:" />
      <item value="If `false`, the mixin will iterate over breakpoints without doing the media query itself. Useful for more complex media query generation as in the margin grid." />
      <item value="If `false`, the mixin will skip the `small` breakpoint. Use this with components that don't prefix classes with `small-`, only `medium-` and up." />
      <item value="Iterates through breakpoints defined in `$breakpoint-classes` and prints the CSS inside the mixin at each breakpoint's media query. Use this with the grid, or any other component that has responsive classes." />
      <item value="Absolutely centers the element inside of its first non-static parent," />
      <item value="Vertically centers the element inside of its first non-static parent," />
      <item value="Reverses the CSS output created by the `element-invisible()` mixin." />
      <item value="Hiding Content for Accessibility" />
      <item value="Makes an element visually hidden, but still accessible to keyboards and assistive devices." />
      <item value="Removes the focus ring around an element when a mouse input is detected." />
      <item value="Maximum number of items to detect. The higher this number is, the more CSS that's required to cover each number of items." />
      <item value="Adds CSS for a &quot;quantity query&quot; selector that automatically sizes elements based on how many there are inside a container." />
      <item value="Applies the micro clearfix hack popularized by Nicolas Gallagher. Include this mixin on a container if its children are all floated, to give the container a proper height." />
      <item value="Adds a downward-facing triangle as a background image to an element. The image is formatted as an SVG, making it easy to change the color. Because Internet Explorer doesn't support encoded SVGs as background images, a PNG fallback is also included." />
      <item value="Spacing between bars is calculated based on the total height of the icon and the weight of each bar" />
      <item value="box-shadow CSS output" />
      <item value="Height of individual bars in the icon." />
      <item value="Creates a menu icon with a set width, height, number of bars, and colors. The mixin uses the height of the icon and the weight of the bars to determine spacing. &lt;div class=&quot;docs-example-burger&quot;&gt;&lt;/div&gt;" />
      <item value="Direction the triangle points. Can be `up`, `right`, `down`, or `left`." />
      <item value="Width of the triangle." />
      <item value="Creates a CSS triangle, which can be used for dropdown arrows, dropdown pips, and more. Use this mixin inside a `&amp;::before` or `&amp;::after` selector, to attach the triangle to an existing element." />
      <item value="Side the shadow is supposed to appear. Can be `top`, `left`, `right` or `bottom`." />
      <item value="Creates an inner box-shadow for only one side" />
      <item value="Otherwise, find the next lowest breakpoint and return that value" />
      <item value="Check if the breakpoint name exists in the local config map" />
      <item value="Check if the breakpoint name exists globally" />
      <item value="The corresponding breakpoint value." />
      <item value="Breakpoint name to use." />
      <item value="Responsive config map or single value." />
      <item value="If the config is a map and does *not* have the breakpoint, the value matching the next lowest breakpoint in the config map is returned." />
      <item value="If the config is a map and has the key `$value`, the exact breakpoint value is returned." />
      <item value="If the config is a single value, return it regardless of `$value`." />
      <item value="Get a value for a breakpoint from a responsive config map or single value." />
      <item value="Return a list of our named breakpoints less than $key. Useful for dealing with" />
      <item value="The list of breakpoints up to and. If $key is auto, returns breakpoints above the zero" />
      <item value="Key to use as last breakpoint." />
      <item value="Return a list of our named breakpoints less than $key. Useful for dealing with&#10;/// responsive gutters for the grid." />
      <item value="If the Key Exists, Get the index of the key within the map and add 1 to it for the next breakpoint in the map" />
      <item value="The value for the key after `$key`, if `$key` was found. If `$key` was not found, or `$key` was the last value in the map, returns `null`." />
      <item value="Key to use as a starting point." />
      <item value="Map to traverse." />
      <item value="Find the next key in a map." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="258" />
        <entry key="ENGLISH" value="258" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
        <entry key="FRENCH" value="1" />
      </map>
    </option>
  </component>
</application>